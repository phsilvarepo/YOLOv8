[
    {
        "id": "e4090b9d8711fef3",
        "type": "tab",
        "label": "YOLOv8_Detector",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "2e622aeab1c37175",
        "type": "tab",
        "label": "YOLOv5_Cases_Detector",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "ac2fb2a82670a34d",
        "type": "tab",
        "label": "YOLOv5_Parts_Detector",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "caf29333161e1c49",
        "type": "function",
        "z": "e4090b9d8711fef3",
        "name": "Preprocessing",
        "func": "const tf = global.get('tf');\ntf.setBackend('tensorflow');\n\nconst originalSize = msg.originalSize;\n\nconst x = tf.cast(\n    tf.expandDims(\n        tf.node.decodeImage(\n            msg.payload\n        ),0 \n    ), \"float32\"\n);\n\nconst normalized = x.div(tf.scalar(255.0))\nreturn {\n    \"payload\":normalized,\n    \"originalSize\": originalSize\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1120,
        "y": 300,
        "wires": [
            [
                "4da5a2dba19744de"
            ]
        ]
    },
    {
        "id": "9ac6a8896b7389cc",
        "type": "change",
        "z": "e4090b9d8711fef3",
        "name": "Add Objects Topic ",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "objects",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 270,
        "y": 420,
        "wires": [
            [
                "bdfeae18bf8264b8"
            ]
        ]
    },
    {
        "id": "bdfeae18bf8264b8",
        "type": "join",
        "z": "e4090b9d8711fef3",
        "name": "Combine Messages",
        "mode": "custom",
        "build": "object",
        "property": "payload",
        "propertyType": "msg",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "accumulate": true,
        "timeout": "",
        "count": "2",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 540,
        "y": 420,
        "wires": [
            [
                "25a998951a4cd6b8"
            ]
        ]
    },
    {
        "id": "25a998951a4cd6b8",
        "type": "function",
        "z": "e4090b9d8711fef3",
        "name": "Assign labels",
        "func": "const objects = msg.payload.objects\n\nconst labelledObjects = objects.map(\n    item => Object({\n        \"bbox\": item[\"bbox\"],\n        \"className\": \"screw\",\n        \"score\": item[\"score\"]\n    })\n)\n\nreturn {\n    \"payload\": {\n        \"image\": msg.payload.image,\n        \"objects\": labelledObjects\n    }\n};",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 770,
        "y": 420,
        "wires": [
            [
                "31af012308aeb09a",
                "e9f38b7e0267cef5"
            ]
        ]
    },
    {
        "id": "c33936eefe42392d",
        "type": "change",
        "z": "e4090b9d8711fef3",
        "name": "Add Image Topic",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "image",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 270,
        "y": 300,
        "wires": [
            [
                "bdfeae18bf8264b8",
                "0d76d75033d19195"
            ]
        ]
    },
    {
        "id": "185aa0e744e9ed11",
        "type": "function",
        "z": "e4090b9d8711fef3",
        "name": "Extract BB",
        "func": "const tf = global.get('tf');\ntf.setBackend('tensorflow');\n\nconst H = 640;\nconst W = 640;\n\nconst originalSize = msg.originalSize;\nconst original_width = originalSize.width;\nconst original_height = originalSize.height;\nconst inputTensor = msg.payload;\nconst tensorValues = inputTensor.arraySync();\nconst tensorArray = tensorValues[0];\n\nfunction calculateIOU(box1, box2) {\n    const x1 = Math.max(box1[0], box2[0]);\n    const y1 = Math.max(box1[1], box2[1]);\n    const x2 = Math.min(box1[0] + box1[2], box2[0] + box2[2]);\n    const y2 = Math.min(box1[1] + box1[3], box2[1] + box2[3]);\n\n    const intersectionArea = Math.max(0, x2 - x1) * Math.max(0, y2 - y1);\n    const box1Area = box1[2] * box1[3];\n    const box2Area = box2[2] * box2[3];\n\n    const iou = intersectionArea / (box1Area + box2Area - intersectionArea);\n    return iou;\n}\n\nfunction applyNMS(boxes, iouThreshold) {\n    const sortedBoxes = boxes.sort((a, b) => b[2] - a[2]);\n    const result = [];\n\n    for (let i = 0; i < sortedBoxes.length; i++) {\n        const currentBox = sortedBoxes[i];\n        result.push(currentBox);\n\n        for (let j = i + 1; j < sortedBoxes.length; j++) {\n            const box = sortedBoxes[j];\n            const iou = calculateIOU(currentBox[0], box[0]);\n\n            if (iou >= iouThreshold) {\n                sortedBoxes.splice(j, 1);\n                j--; // Decrement j to account for the removed element\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction find(tensorArray, numClasses, confidenceThreshold, iouThreshold) {\n    let output = [];\n\n    for (let i = 0; i < 8400; i++) {\n        let x_center;\n        let y_center;\n        let x_min;\n        let y_min;\n        let bb_width;\n        let bb_height;\n        let className;\n        let max_score = 0;\n\n        for (let j = 1; j < numClasses; j++) {\n            let score = tensorArray[j + 3][i];\n\n            if (score > confidenceThreshold && score > max_score) {\n                x_center = tensorArray[0][i];\n                y_center = tensorArray[1][i];\n                bb_width = tensorArray[2][i];\n                bb_height = tensorArray[3][i];\n                className = (j - 1).toString();\n                max_score = score;\n            }\n        }\n\n        if (max_score !== 0) {\n            x_min = x_center - (bb_width / 2);\n            y_min = y_center - (bb_height / 2);\n\n            //Normalize\n            x_min = (x_min * Math.max(original_width, original_height)) / W;\n            y_min = (y_min * Math.max(original_width, original_height)) / H;\n            bb_width = (bb_width * Math.max(original_width, original_height)) / W;\n            bb_height = (bb_height * Math.max(original_width, original_height)) / H;\n\n            if (original_width > original_height) {\n                y_min = y_min - ((original_width - original_height) / 2);\n            }\n            else if (original_width < original_height) {\n                x_min = x_min - ((original_height - original_width) / 2);\n            }\n\n            output.push([[x_min, y_min, bb_width, bb_height], className, max_score]);\n        }\n    }\n\n    const nmsOutput = applyNMS(output, iouThreshold);\n    return nmsOutput;\n}\n\nconst numClasses = tensorValues[0].length - 4; // Assuming there are 4 arrays for the x_center, y_center, bb_width, and bb_height\nconst confidenceThreshold = 0.5; // Confidence threshold for each class\nconst iouThreshold = 0.5; // IOU threshold for NMS\n\nconst bbs = find(tensorArray, numClasses, confidenceThreshold, iouThreshold);\n\nconst keys = [\"bbox\", \"className\", \"score\"];\nconst output = bbs.map(values => Object.fromEntries(keys.map((key, idx) => [key, values[idx]])));\n\nmsg.payload = output;\n\nreturn msg;\n",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1470,
        "y": 300,
        "wires": [
            [
                "ec1deea615c1d301",
                "9ac6a8896b7389cc"
            ]
        ]
    },
    {
        "id": "e9f38b7e0267cef5",
        "type": "debug",
        "z": "e4090b9d8711fef3",
        "name": "debug 36",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 780,
        "y": 480,
        "wires": []
    },
    {
        "id": "ec1deea615c1d301",
        "type": "debug",
        "z": "e4090b9d8711fef3",
        "name": "debug 37",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1660,
        "y": 240,
        "wires": []
    },
    {
        "id": "0d76d75033d19195",
        "type": "function",
        "z": "e4090b9d8711fef3",
        "name": "Find dimensions",
        "func": "const jimp = global.get('Jimp');\n\nconst imageBuffer = msg.payload;\n\n// Use Jimp to read the image and get its dimensions\njimp.read(imageBuffer, (err, image) => {\n    if (err) {\n        // Handle errors\n        msg.payload = { error: err.message };\n        return node.send(msg);\n    }\n\n        // Get the dimensions\n    const width = image.bitmap.width;\n    const height = image.bitmap.height;\n\n    // Output the dimensions to the debug node\n    msg.originalSize = { width, height };\n\n    let letterboxedImage;\n\n    if (width == height) {\n        msg.payload = imageBuffer;\n        return node.send(msg);\n    } else if (width > height) {\n        letterboxedImage = new jimp(width, width, 0x000000FF);\n        letterboxedImage.composite(image, 0, Math.round((width - height) / 2));\n    } else {\n        letterboxedImage = new jimp(height, height, 0x000000FF);\n        letterboxedImage.composite(image, Math.round((height - width) / 2), 0);\n        }\n\n        // Convert the letterboxed image to buffer\n    letterboxedImage.getBuffer(jimp.MIME_JPEG, (bufferErr, resultBuffer) => {\n        if (bufferErr) {\n                // Handle buffer errors\n            msg.payload = { error: bufferErr.message };\n        } else {\n                // Assign the result buffer to msg.payload\n            msg.payload = resultBuffer;\n        }\n            // Send the modified message to the next node\n        return node.send(msg);\n    });\n});\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 300,
        "wires": [
            [
                "bb88436c7c58f31d",
                "0644e2f6f9956f6c"
            ]
        ]
    },
    {
        "id": "0644e2f6f9956f6c",
        "type": "debug",
        "z": "e4090b9d8711fef3",
        "name": "debug 38",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "originalSize",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 480,
        "y": 240,
        "wires": []
    },
    {
        "id": "2111a3b20391b579",
        "type": "debug",
        "z": "e4090b9d8711fef3",
        "name": "debug 39",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1480,
        "y": 160,
        "wires": []
    },
    {
        "id": "31566e9b1a60dfa5",
        "type": "fileinject",
        "z": "e4090b9d8711fef3",
        "name": "Image File",
        "x": 160,
        "y": 220,
        "wires": [
            [
                "c33936eefe42392d"
            ]
        ]
    },
    {
        "id": "df4d6a5e7fbebae8",
        "type": "image",
        "z": "e4090b9d8711fef3",
        "name": "Output",
        "width": "400",
        "data": "payload",
        "dataType": "msg",
        "thumbnail": false,
        "active": true,
        "pass": false,
        "outputs": 0,
        "x": 1270,
        "y": 420,
        "wires": []
    },
    {
        "id": "bb88436c7c58f31d",
        "type": "image",
        "z": "e4090b9d8711fef3",
        "name": "",
        "width": "160",
        "data": "payload",
        "dataType": "msg",
        "thumbnail": false,
        "active": true,
        "pass": true,
        "outputs": 1,
        "x": 740,
        "y": 160,
        "wires": [
            [
                "3dbea01ac1b1f4d8"
            ]
        ]
    },
    {
        "id": "31af012308aeb09a",
        "type": "bbox-image",
        "z": "e4090b9d8711fef3",
        "strokeWidth": "3",
        "fontSize": "10",
        "objectsProp": "objects",
        "objectsPropType": "msgPayload",
        "imageProp": "image",
        "imagePropType": "msgPayload",
        "name": "",
        "x": 1010,
        "y": 420,
        "wires": [
            [
                "df4d6a5e7fbebae8"
            ]
        ]
    },
    {
        "id": "4da5a2dba19744de",
        "type": "tf-model",
        "z": "e4090b9d8711fef3",
        "modelURL": "http://192.168.3.110:8000/model.json",
        "outputNode": "",
        "name": "YOLOv8",
        "x": 1300,
        "y": 300,
        "wires": [
            [
                "185aa0e744e9ed11",
                "2111a3b20391b579"
            ]
        ]
    },
    {
        "id": "3dbea01ac1b1f4d8",
        "type": "jimp-image",
        "z": "e4090b9d8711fef3",
        "name": "",
        "data": "payload",
        "dataType": "msg",
        "ret": "buf",
        "parameter1": "640",
        "parameter1Type": "num",
        "parameter2": "640",
        "parameter2Type": "num",
        "parameter3": "",
        "parameter3Type": "msg",
        "parameter4": "",
        "parameter4Type": "msg",
        "parameter5": "",
        "parameter5Type": "msg",
        "parameter6": "",
        "parameter6Type": "msg",
        "parameter7": "",
        "parameter7Type": "msg",
        "parameter8": "",
        "parameter8Type": "msg",
        "sendProperty": "payload",
        "sendPropertyType": "msg",
        "parameterCount": 3,
        "jimpFunction": "resize",
        "selectedJimpFunction": {
            "name": "resize",
            "fn": "resize",
            "description": "resize the image. One of the w or h parameters can be set to automatic (\"Jimp.AUTO\" or -1).",
            "parameters": [
                {
                    "name": "w",
                    "type": "num|auto",
                    "required": true,
                    "hint": "the width to resize the image to (or \"Jimp.AUTO\" or -1)"
                },
                {
                    "name": "h",
                    "type": "num|auto",
                    "required": true,
                    "hint": "the height to resize the image to (or \"Jimp.AUTO\" or -1)"
                },
                {
                    "name": "mode",
                    "type": "resizeMode",
                    "required": false,
                    "hint": "a scaling method (e.g. Jimp.RESIZE_BEZIER)"
                }
            ]
        },
        "x": 950,
        "y": 300,
        "wires": [
            [
                "caf29333161e1c49"
            ]
        ]
    },
    {
        "id": "e0a8320b295681a0",
        "type": "function",
        "z": "2e622aeab1c37175",
        "name": "Preprocessing",
        "func": "const tf = global.get('tf');\ntf.setBackend('tensorflow');\n\nconst originalSize = msg.originalSize;\n\nconst x = tf.cast(\n    tf.expandDims(\n        tf.node.decodeImage(\n            msg.payload\n        ),0 \n    ), \"float32\"\n);\n\nconst normalized = x.div(tf.scalar(255.0))\nreturn {\n    \"payload\":normalized,\n    \"originalSize\": originalSize\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1100,
        "y": 220,
        "wires": [
            [
                "302947e2f1e23048"
            ]
        ]
    },
    {
        "id": "ca796f5e59c29e55",
        "type": "change",
        "z": "2e622aeab1c37175",
        "name": "Add Objects Topic ",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "objects",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 250,
        "y": 340,
        "wires": [
            [
                "42fc8c216319a3f4"
            ]
        ]
    },
    {
        "id": "42fc8c216319a3f4",
        "type": "join",
        "z": "2e622aeab1c37175",
        "name": "Combine Messages",
        "mode": "custom",
        "build": "object",
        "property": "payload",
        "propertyType": "msg",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "accumulate": true,
        "timeout": "",
        "count": "2",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 520,
        "y": 340,
        "wires": [
            [
                "f43da9e6cbbe96a4"
            ]
        ]
    },
    {
        "id": "f43da9e6cbbe96a4",
        "type": "function",
        "z": "2e622aeab1c37175",
        "name": "Assign labels",
        "func": "const objects = msg.payload.objects;\n\nflow.set(\"labelMap\", [\"Acer_Veriton\", \"Dell_790_SFF\", \"Dell_3020_SFF\", \"Dell_3040_SFF\", \"HP_600_G1_MD\", \"HP_800_G1_SFF\", \"HP_8200_CMT\",\"HP_8200_SFF\", \"HP_Z420\", \"HP_800_G3_MD\"]);\n\n// Retrieve it immediately after setting\nconst labelMap = flow.get(\"labelMap\");\n\nnode.warn(\"labelMap: \" + JSON.stringify(labelMap));\n\nconst labelledObjects = objects.map(item => ({\n    bbox: item.bbox,\n    className: labelMap[parseInt(item.className)], // Convert string to number\n    score: item.score\n}));\n\nreturn {\n    payload: {\n        image: msg.payload.image,\n        objects: labelledObjects\n    }\n};\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 750,
        "y": 340,
        "wires": [
            [
                "fbb46e27a06363fe",
                "1e1cc8914153da2e"
            ]
        ]
    },
    {
        "id": "acbbcdb2b11dc6ef",
        "type": "change",
        "z": "2e622aeab1c37175",
        "name": "Add Image Topic",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "image",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 250,
        "y": 220,
        "wires": [
            [
                "42fc8c216319a3f4",
                "1a870702898a6784"
            ]
        ]
    },
    {
        "id": "fb96a20f72c825ce",
        "type": "function",
        "z": "2e622aeab1c37175",
        "name": "Convert Tensor",
        "func": "const tf = global.get('tf');\ntf.setBackend('tensorflow');\n\nconst originalSize = msg.originalSize;\n\nconst tensorValues = msg.payload.map(tensor => tensor.arraySync())\n\nreturn {\n    payload: tensorValues,\n    originalSize: originalSize\n};",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1460,
        "y": 220,
        "wires": [
            [
                "02be64b36e309df0"
            ]
        ]
    },
    {
        "id": "02be64b36e309df0",
        "type": "function",
        "z": "2e622aeab1c37175",
        "name": "Extract BB",
        "func": "function zip(arrays) {\n    /*\n    This function is equivalent to the python's zip function, for three arrays.\n    */\n    return arrays[0].map(function (_, i) {\n        return arrays.map(function (array) { return array[i] })\n    });\n}\n\nconst H = 640;\nconst W = 640;\n\nconst originalSize = msg.originalSize;\nconst detection_array = msg.payload;\nconst original_width = originalSize.width;\nconst original_height = originalSize.height;\n\nconst conf_threshold = 0.70;\nlet bboxes = [];\nlet scores = [];\nlet classes = [];\n\n// Assuming array[2] is an array of confidence values and array[0] is an array of bounding box coordinates\nfor (let i = 0; i < 100; i++) {\n    if (detection_array[1][0][i] >= conf_threshold) {\n        let x_min = detection_array[0][0][i][0];\n        let y_min = detection_array[0][0][i][1];\n        let x_max = detection_array[0][0][i][2];\n        let y_max = detection_array[0][0][i][3];\n\n\n        x_min = parseInt(Math.max(1.0, x_min * W));\n        y_min = parseInt(Math.max(1.0, y_min * H));\n        let width = parseInt(x_max * W - x_min);\n        let height = parseInt(y_max * H - y_min);\n\n        //Normalize\n        x_min = (x_min * Math.max(original_width, original_height)) / W;\n        y_min = (y_min * Math.max(original_width, original_height)) / H;\n        width = (width * Math.max(original_width, original_height)) / W;\n        height = (height * Math.max(original_width, original_height)) / H;\n\n        if (original_width > original_height) {\n            y_min = y_min - ((original_width - original_height) / 2);      \n        }\n        else if (original_width < original_height) {\n            x_min = x_min - ((original_height - original_width) / 2);\n        }\n        \n        let xyxy = [x_min, y_min, width, height];\n\n        scores.push(detection_array[1][0][i])\n        bboxes.push(xyxy);\n        classes.push(detection_array[2][0][i].toString())\n    }\n}\nconst z = zip([bboxes, classes, scores])\n// Here we convert the outputs from a zipped list to a list of dictionaries, which is\n// the format that the bbox visualization tool accepts.\nconst keys = [\"bbox\", \"className\", \"score\"]\nconst output = z.map(values => Object.fromEntries(keys.map((key, idx) => [key, values[idx]])));\n\n// Return the filtered bounding boxes\nreturn {\n    payload: output\n};",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1650,
        "y": 220,
        "wires": [
            [
                "d46fcf2c348a8b4c",
                "ca796f5e59c29e55"
            ]
        ]
    },
    {
        "id": "1e1cc8914153da2e",
        "type": "debug",
        "z": "2e622aeab1c37175",
        "name": "debug 29",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 760,
        "y": 400,
        "wires": []
    },
    {
        "id": "d46fcf2c348a8b4c",
        "type": "debug",
        "z": "2e622aeab1c37175",
        "name": "debug 30",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1640,
        "y": 160,
        "wires": []
    },
    {
        "id": "1a870702898a6784",
        "type": "function",
        "z": "2e622aeab1c37175",
        "name": "Find dimensions",
        "func": "const jimp = global.get('Jimp');\n\nconst imageBuffer = msg.payload;\n\n// Use Jimp to read the image and get its dimensions\njimp.read(imageBuffer, (err, image) => {\n    if (err) {\n        // Handle errors\n        msg.payload = { error: err.message };\n        return node.send(msg);\n    }\n\n        // Get the dimensions\n    const width = image.bitmap.width;\n    const height = image.bitmap.height;\n\n    // Output the dimensions to the debug node\n    msg.originalSize = { width, height };\n\n    let letterboxedImage;\n\n    if (width == height) {\n        msg.payload = imageBuffer;\n        return node.send(msg);\n    } else if (width > height) {\n        letterboxedImage = new jimp(width, width, 0x000000FF);\n        letterboxedImage.composite(image, 0, Math.round((width - height) / 2));\n    } else {\n        letterboxedImage = new jimp(height, height, 0x000000FF);\n        letterboxedImage.composite(image, Math.round((height - width) / 2), 0);\n        }\n\n        // Convert the letterboxed image to buffer\n    letterboxedImage.getBuffer(jimp.MIME_JPEG, (bufferErr, resultBuffer) => {\n        if (bufferErr) {\n                // Handle buffer errors\n            msg.payload = { error: bufferErr.message };\n        } else {\n                // Assign the result buffer to msg.payload\n            msg.payload = resultBuffer;\n        }\n            // Send the modified message to the next node\n        return node.send(msg);\n    });\n});\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 460,
        "y": 220,
        "wires": [
            [
                "b08d2bedec351a3e",
                "ee2a8010f9ddb4ae"
            ]
        ]
    },
    {
        "id": "ee2a8010f9ddb4ae",
        "type": "debug",
        "z": "2e622aeab1c37175",
        "name": "debug 35",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "originalSize",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 460,
        "y": 160,
        "wires": []
    },
    {
        "id": "aa912b9b0c5937f5",
        "type": "fileinject",
        "z": "2e622aeab1c37175",
        "name": "Image File",
        "x": 140,
        "y": 140,
        "wires": [
            [
                "acbbcdb2b11dc6ef"
            ]
        ]
    },
    {
        "id": "e2614d8d21f3d8c2",
        "type": "image",
        "z": "2e622aeab1c37175",
        "name": "Output",
        "width": "400",
        "data": "payload",
        "dataType": "msg",
        "thumbnail": false,
        "active": true,
        "pass": false,
        "outputs": 0,
        "x": 1250,
        "y": 340,
        "wires": []
    },
    {
        "id": "b08d2bedec351a3e",
        "type": "image",
        "z": "2e622aeab1c37175",
        "name": "",
        "width": "160",
        "data": "payload",
        "dataType": "msg",
        "thumbnail": false,
        "active": true,
        "pass": true,
        "outputs": 1,
        "x": 740,
        "y": 100,
        "wires": [
            [
                "26e10ee0689c55f2"
            ]
        ]
    },
    {
        "id": "fbb46e27a06363fe",
        "type": "bbox-image",
        "z": "2e622aeab1c37175",
        "strokeWidth": "3",
        "fontSize": "10",
        "objectsProp": "objects",
        "objectsPropType": "msgPayload",
        "imageProp": "image",
        "imagePropType": "msgPayload",
        "name": "",
        "x": 990,
        "y": 340,
        "wires": [
            [
                "e2614d8d21f3d8c2"
            ]
        ]
    },
    {
        "id": "302947e2f1e23048",
        "type": "tf-model",
        "z": "2e622aeab1c37175",
        "modelURL": "file:///data/cases_web_model/model.json",
        "outputNode": "",
        "name": "YOLOv5",
        "x": 1280,
        "y": 220,
        "wires": [
            [
                "fb96a20f72c825ce"
            ]
        ]
    },
    {
        "id": "26e10ee0689c55f2",
        "type": "jimp-image",
        "z": "2e622aeab1c37175",
        "name": "",
        "data": "payload",
        "dataType": "msg",
        "ret": "buf",
        "parameter1": "640",
        "parameter1Type": "num",
        "parameter2": "640",
        "parameter2Type": "num",
        "parameter3": "",
        "parameter3Type": "msg",
        "parameter4": "",
        "parameter4Type": "msg",
        "parameter5": "",
        "parameter5Type": "msg",
        "parameter6": "",
        "parameter6Type": "msg",
        "parameter7": "",
        "parameter7Type": "msg",
        "parameter8": "",
        "parameter8Type": "msg",
        "sendProperty": "payload",
        "sendPropertyType": "msg",
        "parameterCount": 3,
        "jimpFunction": "resize",
        "selectedJimpFunction": {
            "name": "resize",
            "fn": "resize",
            "description": "resize the image. One of the w or h parameters can be set to automatic (\"Jimp.AUTO\" or -1).",
            "parameters": [
                {
                    "name": "w",
                    "type": "num|auto",
                    "required": true,
                    "hint": "the width to resize the image to (or \"Jimp.AUTO\" or -1)"
                },
                {
                    "name": "h",
                    "type": "num|auto",
                    "required": true,
                    "hint": "the height to resize the image to (or \"Jimp.AUTO\" or -1)"
                },
                {
                    "name": "mode",
                    "type": "resizeMode",
                    "required": false,
                    "hint": "a scaling method (e.g. Jimp.RESIZE_BEZIER)"
                }
            ]
        },
        "x": 930,
        "y": 220,
        "wires": [
            [
                "e0a8320b295681a0"
            ]
        ]
    },
    {
        "id": "bc1b1a0dde1b26df",
        "type": "function",
        "z": "ac2fb2a82670a34d",
        "name": "Preprocessing",
        "func": "const tf = global.get('tf');\ntf.setBackend('tensorflow');\n\nconst originalSize = msg.originalSize;\n\nconst x = tf.cast(\n    tf.expandDims(\n        tf.node.decodeImage(\n            msg.payload\n        ),0 \n    ), \"float32\"\n);\n\nconst normalized = x.div(tf.scalar(255.0))\nreturn {\n    \"payload\":normalized,\n    \"originalSize\": originalSize\n}",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1420,
        "y": 320,
        "wires": [
            [
                "ca7939fd26807e14"
            ]
        ]
    },
    {
        "id": "191d781476ae229a",
        "type": "change",
        "z": "ac2fb2a82670a34d",
        "name": "Add Objects Topic ",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "objects",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 570,
        "y": 440,
        "wires": [
            [
                "5de8ed6414f70303"
            ]
        ]
    },
    {
        "id": "5de8ed6414f70303",
        "type": "join",
        "z": "ac2fb2a82670a34d",
        "name": "Combine Messages",
        "mode": "custom",
        "build": "object",
        "property": "payload",
        "propertyType": "msg",
        "key": "topic",
        "joiner": "\\n",
        "joinerType": "str",
        "accumulate": true,
        "timeout": "",
        "count": "2",
        "reduceRight": false,
        "reduceExp": "",
        "reduceInit": "",
        "reduceInitType": "",
        "reduceFixup": "",
        "x": 840,
        "y": 440,
        "wires": [
            [
                "bb58596b1a666976"
            ]
        ]
    },
    {
        "id": "bb58596b1a666976",
        "type": "function",
        "z": "ac2fb2a82670a34d",
        "name": "Assign labels",
        "func": "const objects = msg.payload.objects;\n\nflow.set(\"labelMap\", [\"psu\", \"hdd\", \"disk_drive\", \"ram_slots\"]);\n\n// Retrieve it immediately after setting\nconst labelMap = flow.get(\"labelMap\");\n\nnode.warn(\"labelMap: \" + JSON.stringify(labelMap));\n\nconst labelledObjects = objects.map(item => ({\n    bbox: item.bbox,\n    className: labelMap[parseInt(item.className)], // Convert string to number\n    score: item.score\n}));\n\nreturn {\n    payload: {\n        image: msg.payload.image,\n        objects: labelledObjects\n    }\n};\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1070,
        "y": 440,
        "wires": [
            [
                "82a1eed6457a9d05",
                "ba1047fcf7bd4b1c"
            ]
        ]
    },
    {
        "id": "9ee822d213f473a1",
        "type": "change",
        "z": "ac2fb2a82670a34d",
        "name": "Add Image Topic",
        "rules": [
            {
                "t": "set",
                "p": "topic",
                "pt": "msg",
                "to": "image",
                "tot": "str"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 570,
        "y": 320,
        "wires": [
            [
                "5de8ed6414f70303",
                "76fac0e07342a63d"
            ]
        ]
    },
    {
        "id": "db9521598dae8c28",
        "type": "function",
        "z": "ac2fb2a82670a34d",
        "name": "Convert Tensor",
        "func": "const tf = global.get('tf');\ntf.setBackend('tensorflow');\n\nconst originalSize = msg.originalSize;\n\nconst tensorValues = msg.payload.map(tensor => tensor.arraySync())\n\nreturn {\n    payload: tensorValues,\n    originalSize: originalSize\n};",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1780,
        "y": 320,
        "wires": [
            [
                "3ddab5f149edf601"
            ]
        ]
    },
    {
        "id": "3ddab5f149edf601",
        "type": "function",
        "z": "ac2fb2a82670a34d",
        "name": "Extract BB",
        "func": "function zip(arrays) {\n    /*\n    This function is equivalent to the python's zip function, for three arrays.\n    */\n    return arrays[0].map(function (_, i) {\n        return arrays.map(function (array) { return array[i] })\n    });\n}\n\nconst H = 640;\nconst W = 640;\n\nconst originalSize = msg.originalSize;\nconst detection_array = msg.payload;\nconst original_width = originalSize.width;\nconst original_height = originalSize.height;\n\nconst conf_threshold = 0.70;\nlet bboxes = [];\nlet scores = [];\nlet classes = [];\n\n// Assuming array[2] is an array of confidence values and array[0] is an array of bounding box coordinates\nfor (let i = 0; i < 100; i++) {\n    if (detection_array[1][0][i] >= conf_threshold) {\n        let x_min = detection_array[0][0][i][0];\n        let y_min = detection_array[0][0][i][1];\n        let x_max = detection_array[0][0][i][2];\n        let y_max = detection_array[0][0][i][3];\n\n\n        x_min = parseInt(Math.max(1.0, x_min * W));\n        y_min = parseInt(Math.max(1.0, y_min * H));\n        let width = parseInt(x_max * W - x_min);\n        let height = parseInt(y_max * H - y_min);\n\n        //Normalize\n        x_min = (x_min * Math.max(original_width, original_height)) / W;\n        y_min = (y_min * Math.max(original_width, original_height)) / H;\n        width = (width * Math.max(original_width, original_height)) / W;\n        height = (height * Math.max(original_width, original_height)) / H;\n\n        if (original_width > original_height) {\n            y_min = y_min - ((original_width - original_height) / 2);      \n        }\n        else if (original_width < original_height) {\n            x_min = x_min - ((original_height - original_width) / 2);\n        }\n        \n        let xyxy = [x_min, y_min, width, height];\n\n        scores.push(detection_array[1][0][i])\n        bboxes.push(xyxy);\n        classes.push(detection_array[2][0][i].toString())\n    }\n}\nconst z = zip([bboxes, classes, scores])\n// Here we convert the outputs from a zipped list to a list of dictionaries, which is\n// the format that the bbox visualization tool accepts.\nconst keys = [\"bbox\", \"className\", \"score\"]\nconst output = z.map(values => Object.fromEntries(keys.map((key, idx) => [key, values[idx]])));\n\n// Return the filtered bounding boxes\nreturn {\n    payload: output\n};",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1970,
        "y": 320,
        "wires": [
            [
                "191d781476ae229a",
                "75e96fe1218eb18f"
            ]
        ]
    },
    {
        "id": "ba1047fcf7bd4b1c",
        "type": "debug",
        "z": "ac2fb2a82670a34d",
        "name": "debug 40",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1080,
        "y": 500,
        "wires": []
    },
    {
        "id": "75e96fe1218eb18f",
        "type": "debug",
        "z": "ac2fb2a82670a34d",
        "name": "debug 41",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 1960,
        "y": 260,
        "wires": []
    },
    {
        "id": "76fac0e07342a63d",
        "type": "function",
        "z": "ac2fb2a82670a34d",
        "name": "Find dimensions",
        "func": "const jimp = global.get('Jimp');\n\nconst imageBuffer = msg.payload;\n\n// Use Jimp to read the image and get its dimensions\njimp.read(imageBuffer, (err, image) => {\n    if (err) {\n        // Handle errors\n        msg.payload = { error: err.message };\n        return node.send(msg);\n    }\n\n        // Get the dimensions\n    const width = image.bitmap.width;\n    const height = image.bitmap.height;\n\n    // Output the dimensions to the debug node\n    msg.originalSize = { width, height };\n\n    let letterboxedImage;\n\n    if (width == height) {\n        msg.payload = imageBuffer;\n        return node.send(msg);\n    } else if (width > height) {\n        letterboxedImage = new jimp(width, width, 0x000000FF);\n        letterboxedImage.composite(image, 0, Math.round((width - height) / 2));\n    } else {\n        letterboxedImage = new jimp(height, height, 0x000000FF);\n        letterboxedImage.composite(image, Math.round((height - width) / 2), 0);\n        }\n\n        // Convert the letterboxed image to buffer\n    letterboxedImage.getBuffer(jimp.MIME_JPEG, (bufferErr, resultBuffer) => {\n        if (bufferErr) {\n                // Handle buffer errors\n            msg.payload = { error: bufferErr.message };\n        } else {\n                // Assign the result buffer to msg.payload\n            msg.payload = resultBuffer;\n        }\n            // Send the modified message to the next node\n        return node.send(msg);\n    });\n});\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 780,
        "y": 320,
        "wires": [
            [
                "b19dbc17b0a16b9c",
                "90e8cc8637919b9a"
            ]
        ]
    },
    {
        "id": "90e8cc8637919b9a",
        "type": "debug",
        "z": "ac2fb2a82670a34d",
        "name": "debug 42",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "originalSize",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 780,
        "y": 260,
        "wires": []
    },
    {
        "id": "fcec8a4fca6cf43b",
        "type": "fileinject",
        "z": "ac2fb2a82670a34d",
        "name": "Image File",
        "x": 460,
        "y": 240,
        "wires": [
            [
                "9ee822d213f473a1"
            ]
        ]
    },
    {
        "id": "a7609c0622cd56b6",
        "type": "image",
        "z": "ac2fb2a82670a34d",
        "name": "Output",
        "width": "400",
        "data": "payload",
        "dataType": "msg",
        "thumbnail": false,
        "active": true,
        "pass": false,
        "outputs": 0,
        "x": 1570,
        "y": 440,
        "wires": []
    },
    {
        "id": "b19dbc17b0a16b9c",
        "type": "image",
        "z": "ac2fb2a82670a34d",
        "name": "",
        "width": "160",
        "data": "payload",
        "dataType": "msg",
        "thumbnail": false,
        "active": true,
        "pass": true,
        "outputs": 1,
        "x": 1060,
        "y": 200,
        "wires": [
            [
                "e1d90f9b587fd724"
            ]
        ]
    },
    {
        "id": "82a1eed6457a9d05",
        "type": "bbox-image",
        "z": "ac2fb2a82670a34d",
        "strokeWidth": "3",
        "fontSize": "10",
        "objectsProp": "objects",
        "objectsPropType": "msgPayload",
        "imageProp": "image",
        "imagePropType": "msgPayload",
        "name": "",
        "x": 1310,
        "y": 440,
        "wires": [
            [
                "a7609c0622cd56b6"
            ]
        ]
    },
    {
        "id": "ca7939fd26807e14",
        "type": "tf-model",
        "z": "ac2fb2a82670a34d",
        "modelURL": "file:///data/parts_web_model/model.json",
        "outputNode": "",
        "name": "YOLOv5",
        "x": 1600,
        "y": 320,
        "wires": [
            [
                "db9521598dae8c28"
            ]
        ]
    },
    {
        "id": "e1d90f9b587fd724",
        "type": "jimp-image",
        "z": "ac2fb2a82670a34d",
        "name": "",
        "data": "payload",
        "dataType": "msg",
        "ret": "buf",
        "parameter1": "640",
        "parameter1Type": "num",
        "parameter2": "640",
        "parameter2Type": "num",
        "parameter3": "",
        "parameter3Type": "msg",
        "parameter4": "",
        "parameter4Type": "msg",
        "parameter5": "",
        "parameter5Type": "msg",
        "parameter6": "",
        "parameter6Type": "msg",
        "parameter7": "",
        "parameter7Type": "msg",
        "parameter8": "",
        "parameter8Type": "msg",
        "sendProperty": "payload",
        "sendPropertyType": "msg",
        "parameterCount": 3,
        "jimpFunction": "resize",
        "selectedJimpFunction": {
            "name": "resize",
            "fn": "resize",
            "description": "resize the image. One of the w or h parameters can be set to automatic (\"Jimp.AUTO\" or -1).",
            "parameters": [
                {
                    "name": "w",
                    "type": "num|auto",
                    "required": true,
                    "hint": "the width to resize the image to (or \"Jimp.AUTO\" or -1)"
                },
                {
                    "name": "h",
                    "type": "num|auto",
                    "required": true,
                    "hint": "the height to resize the image to (or \"Jimp.AUTO\" or -1)"
                },
                {
                    "name": "mode",
                    "type": "resizeMode",
                    "required": false,
                    "hint": "a scaling method (e.g. Jimp.RESIZE_BEZIER)"
                }
            ]
        },
        "x": 1250,
        "y": 320,
        "wires": [
            [
                "bc1b1a0dde1b26df"
            ]
        ]
    }
]